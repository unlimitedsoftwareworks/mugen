/* oh god why .. */
#include "no_sillywarnings_please.h"

#include <stdio.h>
#include <stdlib.h>
#include <wchar.h>                  /* wchar_t */
#include <sys/stat.h>
#include <assert.h>
#include <string.h>

#include "memory.h"
#include "engine.h"                 /* The Kessels engine. */
#include "grammar.h"                /* Generated by GOLD. */
#include "parser.h"
#include "datatypes.h"
#include "utilities.h"
#include "defines.h"

#define TRIMREDUCTIONS 0            /* 0=off, 1=on */
#define DEBUG          1            /* 0=off, 1=on */


#define parseExpr(i, p) RuleJumpTable[Token->Tokens[i]->ReductionRule](Token->Tokens[i], p)

extern int libDirSize;
extern char* libDir;


/* Forward definition of the RuleJumpTable. It will be filled with a link
to a subroutine for every rule later on. */
void(*RuleJumpTable[])(struct TokenStruct *Token, struct ContextStruct *parent);




/***** Helper subroutines ***************************************************/


/* Make a readable copy of a string. All characters outside 32...127 are
displayed as a HEX number in square brackets, for example "[0A]". */
void ReadableString(wchar_t *Input, wchar_t *Output, long Width) {
	char s1[BUFSIZ];
	long i1;
	long i2;

	/* Sanity check. */
	if ((Output == NULL) || (Width < 1)) return;
	Output[0] = 0;
	if (Input == NULL) return;

	i1 = 0;
	i2 = 0;
	while ((i2 < Width - 1) && (Input[i1] != 0)) {
		if ((Input[i1] >= 32) && (Input[i1] <= 127)) {
			Output[i2++] = Input[i1];
		}
		else {
			if (Width - i2 > 4) {
				sprintf(s1, "%02X", Input[i1]);
				Output[i2++] = '[';
				Output[i2++] = s1[0];
				Output[i2++] = s1[1];
				Output[i2++] = ']';
			}
		}
		i1++;
	}
	Output[i2] = 0;
}


void ShowIndent(int Indent) {
	int i;
	for (i = 0; i < Indent; i++)
		fprintf(stdout, "  ");
}

/***** Rule subroutine template *********************************************/

/* This subroutine is a template of things that can happen in the
subroutine of a rule. It shows how to access the value of symbols
and how to call rules, and how to transport results and stuff via
the parent.

For example the rule:

<Increment> ::= <Expression> '+' Number

Has 3 sub-tokens:

Token->Tokens[0] = token for <Expression>, a rule
Token->Tokens[1] = token for '+', a symbol
Token->Tokens[2] = token for Number, a symbol

We know Token->Tokens[0] is a rule, because that's what the grammar
says. We may assume that the engine has fully populated the sub-tokens
and don't have to perform any checks. We can immediately call the
subroutine of the rule, like this:

RuleJumpTable[Token->Tokens[0]->ReductionRule](Token->Tokens[0],parent);

The subroutine should hand back it's results via the parent. Here
is an example of how to store a result in the context:

parent->ReturnValue = (wchar_t *)wcsdup(....);

Symbols are literal strings from the input (that was parsed by the
engine), stored in the sub-token. We can get the value of the "Number"
symbol like this:

Value = (wchar_t *)wcsdup(Token->Tokens[2]->Data);

Further reading:
- See "engine.h" for the definition of the TokenStruct.
- See "readme.txt" for a short discussion on how to use the content
of a Token.
- See "example4.c" for a working template example.
*/

void RuleTemplate(struct TokenStruct *Token, struct ContextStruct *parent) {
	int i;

	/* Debugging: show the description of the rule. */
	if (parent->Debug > 0) {
		ShowIndent(parent->Indent);
		fprintf(stdout, "Executing rule: %ls\n", Grammar.RuleArray[Token->ReductionRule].Description);
	}

	/* For all the sub-Tokens. */
	for (i = 0; i < Grammar.RuleArray[Token->ReductionRule].SymbolsCount; i++) {
		/* See if the Token is a Symbol or a Rule. */
		if (Token->Tokens[i]->ReductionRule < 0) {
			/* It's a Symbol. Make a copy of the Data. Most symbols are grammar,
			for example '+', 'function', 'while', and such, and you won't
			need to look at the Data. Other symbols are literals from the input
			script, for example numbers, strings, variable names, and such. */
			if (parent->ReturnValue != NULL) dmt_free(parent->ReturnValue);
			parent->ReturnValue = (wchar_t *)wcsdup(Token->Tokens[i]->Data);

			/* Debugging: show a description of the Symbol, and it's value. */
			if (parent->Debug > 0) {
				ShowIndent(parent->Indent + 1);
				fprintf(stdout, "Token[%u] = Symbol('%ls') = '%ls'\n", i,
					Grammar.SymbolArray[Token->Tokens[i]->Symbol].Name,
					parent->ReturnValue);
			}

		}
		else {
			/* It's a rule. */

			/* Debugging: show a description of the rule. */
			if (parent->Debug > 0) {
				ShowIndent(parent->Indent + 1);
				fprintf(stdout, "Token[%u] = Rule = %ls\n", i,
					Grammar.RuleArray[Token->Tokens[i]->ReductionRule].Description);
			}

			/* Call the rule's subroutine via the RuleJumpTable. */
			parent->Indent = parent->Indent + 1;
			RuleJumpTable[Token->Tokens[i]->ReductionRule](Token->Tokens[i], parent);
			parent->Indent = parent->Indent - 1;

			/* At this point you will probably want to save the parent->ReturnValue
			somewhere. */

			/* Debugging: show the value that was returned by the rule's subroutine. */
			if (parent->Debug > 0) {
				ShowIndent(parent->Indent + 2);
				fprintf(stdout, "Result value = %ls\n", parent->ReturnValue);
			}
		}
	}

	/* Do whatever processing is needed by the rule. Remember to free() the
	Values you have saved. */
}


/***** Rule subroutines *****************************************************/



/* <Program> ::= <Import Section> <Declarations> */
void Rule_Program(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Import Section> ::= import '(' <Import Expr List> ')' */
void Rule_ImportSection_import_LParen_RParen(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Import Section> ::= import '(' ')' */
void Rule_ImportSection_import_LParen_RParen2(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Import Section> ::=  */
void Rule_ImportSection(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Import Expr List> ::= <Import Path> ',' <Import Expr List> */
void Rule_ImportExprList_Comma(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Import Expr List> ::= <Import Path> */
void Rule_ImportExprList(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Import Path> ::= Identifier '.' <Import Path> */
void Rule_ImportPath_Identifier_Dot(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Import Path> ::= Identifier */
void Rule_ImportPath_Identifier(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Declarations> ::= <Decl> <Declarations> */
void Rule_Declarations(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Declarations> ::=  */
void Rule_Declarations2(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Decl> ::= <LType Decl> */
void Rule_Decl(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Decl> ::= <LVar Decl> */
void Rule_Decl2(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Decl> ::= <LFunction Decl> */
void Rule_Decl3(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <LType Decl> ::= local <Type Decl> */
void Rule_LTypeDecl_local(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <LType Decl> ::= <Type Decl> */
void Rule_LTypeDecl(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Type Decl> ::= <Enum Decl> */
void Rule_TypeDecl(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Type Decl> ::= <Interface Def> */
void Rule_TypeDecl2(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Type Decl> ::= <Class Def> */
void Rule_TypeDecl3(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Type Decl> ::= <Type Def> */
void Rule_TypeDecl4(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Enum Decl> ::= enum Identifier '{' <Enum Values> '}' */
void Rule_EnumDecl_enum_Identifier_LBrace_RBrace(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Enum Values> ::= <Enum Value> ',' <Enum Values> */
void Rule_EnumValues_Comma(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Enum Values> ::= <Enum Value> */
void Rule_EnumValues(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Enum Value> ::= Identifier */
void Rule_EnumValue_Identifier(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Interface Def> ::= interface Identifier '{' <Interface Methods> '}' */
void Rule_InterfaceDef_interface_Identifier_LBrace_RBrace(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Interface Def> ::= interface Identifier '<' <Id List> '>' '{' <Interface Methods> '}' */
void Rule_InterfaceDef_interface_Identifier_Lt_Gt_LBrace_RBrace(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Interface Methods> ::= <Interface Method> <Interface Methods> */
void Rule_InterfaceMethods(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Interface Methods> ::= <Interface Method> */
void Rule_InterfaceMethods2(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Interface Method> ::= function <Func Name> '(' <Params> ')' '->' <Types> */
void Rule_InterfaceMethod_function_LParen_RParen_MinusGt(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Interface Method> ::= function <Func Name> '(' ')' '->' <Types> */
void Rule_InterfaceMethod_function_LParen_RParen_MinusGt2(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Interface Method> ::= function <Func Name> '(' <Params> ')' */
void Rule_InterfaceMethod_function_LParen_RParen(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Interface Method> ::= function <Func Name> '(' ')' */
void Rule_InterfaceMethod_function_LParen_RParen2(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Interface Method> ::= local function <Func Name> '(' <Params> ')' '->' <Types> */
void Rule_InterfaceMethod_local_function_LParen_RParen_MinusGt(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Interface Method> ::= local function <Func Name> '(' ')' '->' <Types> */
void Rule_InterfaceMethod_local_function_LParen_RParen_MinusGt2(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Interface Method> ::= local function <Func Name> '(' <Params> ')' */
void Rule_InterfaceMethod_local_function_LParen_RParen(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Interface Method> ::= local function <Func Name> '(' ')' */
void Rule_InterfaceMethod_local_function_LParen_RParen2(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Interface Method> ::= synchronized function <Func Name> '(' <Params> ')' '->' <Types> */
void Rule_InterfaceMethod_synchronized_function_LParen_RParen_MinusGt(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Interface Method> ::= synchronized function <Func Name> '(' ')' '->' <Types> */
void Rule_InterfaceMethod_synchronized_function_LParen_RParen_MinusGt2(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Interface Method> ::= synchronized function <Func Name> '(' <Params> ')' */
void Rule_InterfaceMethod_synchronized_function_LParen_RParen(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Interface Method> ::= synchronized function <Func Name> '(' ')' */
void Rule_InterfaceMethod_synchronized_function_LParen_RParen2(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Interface Method> ::= local synchronized function <Func Name> '(' <Params> ')' '->' <Types> */
void Rule_InterfaceMethod_local_synchronized_function_LParen_RParen_MinusGt(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Interface Method> ::= local synchronized function <Func Name> '(' ')' '->' <Types> */
void Rule_InterfaceMethod_local_synchronized_function_LParen_RParen_MinusGt2(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Interface Method> ::= local synchronized function <Func Name> '(' <Params> ')' */
void Rule_InterfaceMethod_local_synchronized_function_LParen_RParen(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Interface Method> ::= local synchronized function <Func Name> '(' ')' */
void Rule_InterfaceMethod_local_synchronized_function_LParen_RParen2(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Interface Method> ::= synchronized local function <Func Name> '(' <Params> ')' '->' <Types> */
void Rule_InterfaceMethod_synchronized_local_function_LParen_RParen_MinusGt(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Interface Method> ::= synchronized local function <Func Name> '(' ')' '->' <Types> */
void Rule_InterfaceMethod_synchronized_local_function_LParen_RParen_MinusGt2(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Interface Method> ::= synchronized local function <Func Name> '(' <Params> ')' */
void Rule_InterfaceMethod_synchronized_local_function_LParen_RParen(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Interface Method> ::= synchronized local function <Func Name> '(' ')' */
void Rule_InterfaceMethod_synchronized_local_function_LParen_RParen2(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Func Name> ::= Identifier */
void Rule_FuncName_Identifier(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Func Name> ::= <Overrideable Operator> */
void Rule_FuncName(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Class Def> ::= class Identifier '{' <Class Decls> '}' */
void Rule_ClassDef_class_Identifier_LBrace_RBrace(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Class Def> ::= class Identifier implements <Pkg Template List> '{' <Class Decls> '}' */
void Rule_ClassDef_class_Identifier_implements_LBrace_RBrace(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Class Def> ::= immutable class Identifier '{' <Class Decls> '}' */
void Rule_ClassDef_immutable_class_Identifier_LBrace_RBrace(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Class Def> ::= immutable class Identifier implements <Pkg Template List> '{' <Class Decls> '}' */
void Rule_ClassDef_immutable_class_Identifier_implements_LBrace_RBrace(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Class Decls> ::= <Class Decl> <Class Decls> */
void Rule_ClassDecls(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Class Decls> ::= <Class Decl> */
void Rule_ClassDecls2(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Class Decl> ::= <Class Method Decl> */
void Rule_ClassDecl(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Class Decl> ::= <Class Variable Decl> */
void Rule_ClassDecl2(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Class Method Decl> ::= <Interface Method> '=' <Expr> */
void Rule_ClassMethodDecl_Eq(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Class Method Decl> ::= <Interface Method> <Block> */
void Rule_ClassMethodDecl(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Class Variable Decl> ::= <LVar Decl> */
void Rule_ClassVariableDecl(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Type Def> ::= type Identifier '=' <Type> */
void Rule_TypeDef_type_Identifier_Eq(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Overrideable Operator> ::= '+' */
void Rule_OverrideableOperator_Plus(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Overrideable Operator> ::= '-' */
void Rule_OverrideableOperator_Minus(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Overrideable Operator> ::= '*' */
void Rule_OverrideableOperator_Times(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Overrideable Operator> ::= '/' */
void Rule_OverrideableOperator_Div(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Overrideable Operator> ::= '%' */
void Rule_OverrideableOperator_Percent(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Overrideable Operator> ::= '^' */
void Rule_OverrideableOperator_Caret(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Overrideable Operator> ::= '&' */
void Rule_OverrideableOperator_Amp(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Overrideable Operator> ::= '|' */
void Rule_OverrideableOperator_Pipe(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Overrideable Operator> ::= '~' */
void Rule_OverrideableOperator_Tilde(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Overrideable Operator> ::= '!' */
void Rule_OverrideableOperator_Exclam(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Overrideable Operator> ::= '=' */
void Rule_OverrideableOperator_Eq(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Overrideable Operator> ::= '<' */
void Rule_OverrideableOperator_Lt(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Overrideable Operator> ::= '>' */
void Rule_OverrideableOperator_Gt(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Overrideable Operator> ::= '+=' */
void Rule_OverrideableOperator_PlusEq(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Overrideable Operator> ::= '-=' */
void Rule_OverrideableOperator_MinusEq(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Overrideable Operator> ::= '*=' */
void Rule_OverrideableOperator_TimesEq(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Overrideable Operator> ::= '/=' */
void Rule_OverrideableOperator_DivEq(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Overrideable Operator> ::= '%=' */
void Rule_OverrideableOperator_PercentEq(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Overrideable Operator> ::= '^=' */
void Rule_OverrideableOperator_CaretEq(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Overrideable Operator> ::= '&=' */
void Rule_OverrideableOperator_AmpEq(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Overrideable Operator> ::= '|=' */
void Rule_OverrideableOperator_PipeEq(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Overrideable Operator> ::= '<<' */
void Rule_OverrideableOperator_LtLt(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Overrideable Operator> ::= '>>' */
void Rule_OverrideableOperator_GtGt(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Overrideable Operator> ::= '>>=' */
void Rule_OverrideableOperator_GtGtEq(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Overrideable Operator> ::= '<<=' */
void Rule_OverrideableOperator_LtLtEq(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Overrideable Operator> ::= '==' */
void Rule_OverrideableOperator_EqEq(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Overrideable Operator> ::= '!=' */
void Rule_OverrideableOperator_ExclamEq(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Overrideable Operator> ::= '<=' */
void Rule_OverrideableOperator_LtEq(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Overrideable Operator> ::= '>=' */
void Rule_OverrideableOperator_GtEq(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Overrideable Operator> ::= '&&' */
void Rule_OverrideableOperator_AmpAmp(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Overrideable Operator> ::= '||' */
void Rule_OverrideableOperator_PipePipe(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Overrideable Operator> ::= '++' */
void Rule_OverrideableOperator_PlusPlus(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Overrideable Operator> ::= '--' */
void Rule_OverrideableOperator_MinusMinus(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Overrideable Operator> ::= ',' */
void Rule_OverrideableOperator_Comma(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Overrideable Operator> ::= '(' ')' */
void Rule_OverrideableOperator_LParen_RParen(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Overrideable Operator> ::= '[' ']' */
void Rule_OverrideableOperator_LBracket_RBracket(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Overrideable Operator> ::= new */
void Rule_OverrideableOperator_new(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Overrideable Operator> ::= free */
void Rule_OverrideableOperator_free(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <LFunction Decl> ::= <Interface Method> '=' <Expr> */
void Rule_LFunctionDecl_Eq(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <LFunction Decl> ::= <Interface Method> <Block> */
void Rule_LFunctionDecl(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <LVar Decl> ::= let <Id List> ':' <Type> '=' <Expr List> */
void Rule_LVarDecl_let_Colon_Eq(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <LVar Decl> ::= let <Id List> ':' <Type> */
void Rule_LVarDecl_let_Colon(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <LVar Decl> ::= let <Id List> '=' <Expr List> */
void Rule_LVarDecl_let_Eq(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <LVar Decl> ::= let mut <Id List> ':' <Type> '=' <Expr List> */
void Rule_LVarDecl_let_mut_Colon_Eq(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <LVar Decl> ::= let mut <Id List> '=' <Expr List> */
void Rule_LVarDecl_let_mut_Eq(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <LVar Decl> ::= let local <Id List> ':' <Type> '=' <Expr List> */
void Rule_LVarDecl_let_local_Colon_Eq(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <LVar Decl> ::= let local <Id List> ':' <Type> */
void Rule_LVarDecl_let_local_Colon(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <LVar Decl> ::= let local <Id List> '=' <Expr List> */
void Rule_LVarDecl_let_local_Eq(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <LVar Decl> ::= let mut local <Id List> ':' <Type> '=' <Expr List> */
void Rule_LVarDecl_let_mut_local_Colon_Eq(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <LVar Decl> ::= let mut local <Id List> '=' <Expr List> */
void Rule_LVarDecl_let_mut_local_Eq(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <LVar Decl> ::= let local mut <Id List> ':' <Type> '=' <Expr List> */
void Rule_LVarDecl_let_local_mut_Colon_Eq(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <LVar Decl> ::= let local mut <Id List> '=' <Expr List> */
void Rule_LVarDecl_let_local_mut_Eq(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Statements> ::= <Stmt> <Statements> */
void Rule_Statements(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Statements> ::= <Stmt> */
void Rule_Statements2(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Stmt> ::= <Block> */
void Rule_Stmt(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Stmt> ::= <Var Decl Stmt> */
void Rule_Stmt2(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Stmt> ::= <Repeat Stmt> */
void Rule_Stmt3(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Stmt> ::= <While Stmt> */
void Rule_Stmt4(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Stmt> ::= <For Stmt> */
void Rule_Stmt5(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Stmt> ::= <Foreach Stmt> */
void Rule_Stmt6(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Stmt> ::= <Expr> */
void Rule_Stmt7(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Stmt> ::= <Return Stmt> */
void Rule_Stmt8(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Stmt> ::= <Break Stmt> */
void Rule_Stmt9(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Stmt> ::= <Continue Stmt> */
void Rule_Stmt10(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Stmt> ::= <If Stmt> */
void Rule_Stmt11(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Stmt> ::= <Match Stmt> */
void Rule_Stmt12(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Block> ::= '{' <Statements> '}' */
void Rule_Block_LBrace_RBrace(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Block> ::= synchronized '{' <Statements> '}' */
void Rule_Block_synchronized_LBrace_RBrace(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Var Decl Stmt> ::= let <Id List> ':' <Type> '=' <Expr List> */
void Rule_VarDeclStmt_let_Colon_Eq(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Var Decl Stmt> ::= let <Id List> ':' <Type> */
void Rule_VarDeclStmt_let_Colon(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Var Decl Stmt> ::= let <Id List> '=' <Expr List> */
void Rule_VarDeclStmt_let_Eq(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Var Decl Stmt> ::= let mut <Id List> ':' <Type> '=' <Expr List> */
void Rule_VarDeclStmt_let_mut_Colon_Eq(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Var Decl Stmt> ::= let mut <Id List> '=' <Expr List> */
void Rule_VarDeclStmt_let_mut_Eq(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Repeat Stmt> ::= repeat <Block> while <Expr> */
void Rule_RepeatStmt_repeat_while(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <While Stmt> ::= while <Expr> <Block> */
void Rule_WhileStmt_while(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <For Stmt> ::= for <Expr List> ';' <Expr> ';' <Expr List> <Block> */
void Rule_ForStmt_for_Semi_Semi(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Foreach Stmt> ::= foreach Identifier ':' <Type> in <Expr> <Block> */
void Rule_ForeachStmt_foreach_Identifier_Colon_in(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Return Stmt> ::= return <Expr List> */
void Rule_ReturnStmt_return(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Return Stmt> ::= return */
void Rule_ReturnStmt_return2(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Continue Stmt> ::= continue */
void Rule_ContinueStmt_continue(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Break Stmt> ::= break */
void Rule_BreakStmt_break(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <If Stmt> ::= if <Expr> <Block> <Else If Stmt> */
void Rule_IfStmt_if(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Else If Stmt> ::= else <If Stmt> <Else If Stmt> */
void Rule_ElseIfStmt_else(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Else If Stmt> ::= <Else Stmt> */
void Rule_ElseIfStmt(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Else If Stmt> ::=  */
void Rule_ElseIfStmt2(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Else Stmt> ::= else <Block> */
void Rule_ElseStmt_else(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Match Stmt> ::= match <Expr List> '{' <Match List> <Else Element> '}' */
void Rule_MatchStmt_match_LBrace_RBrace(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Match Stmt> ::= match <Expr List> '{' <Match List> '}' */
void Rule_MatchStmt_match_LBrace_RBrace2(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Match List> ::= <Match Element> <Match List> */
void Rule_MatchList(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Match List> ::= <Match Element> */
void Rule_MatchList2(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Match Element> ::= <Expr List> <Block> */
void Rule_MatchElement(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Else Element> ::= else <Block> */
void Rule_ElseElement_else(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Types> ::= <Type> ',' <Types> */
void Rule_Types_Comma(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Types> ::= <Type> */
void Rule_Types(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Type> ::= <Base> */
void Rule_Type(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Type> ::= <Fn Type> */
void Rule_Type2(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Type> ::= <Pkg Template> */
void Rule_Type3(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Type> ::= <Type> '[' ']' */
void Rule_Type_LBracket_RBracket(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Type> ::= '(' <Types> ')' */
void Rule_Type_LParen_RParen(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Type> ::= '[' <Pkg Template List> ']' */
void Rule_Type_LBracket_RBracket2(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Base> ::= Byte */
void Rule_Base_Byte(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Base> ::= Char */
void Rule_Base_Char(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Base> ::= Bool */
void Rule_Base_Bool(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Base> ::= 'Int8' */
void Rule_Base_Int8(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Base> ::= 'UInt8' */
void Rule_Base_UInt8(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Base> ::= 'Int16' */
void Rule_Base_Int16(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Base> ::= 'UInt16' */
void Rule_Base_UInt16(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Base> ::= 'Int32' */
void Rule_Base_Int32(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Base> ::= 'UInt32' */
void Rule_Base_UInt32(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Base> ::= 'Int64' */
void Rule_Base_Int64(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Base> ::= 'UInt64' */
void Rule_Base_UInt64(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Base> ::= Double */
void Rule_Base_Double(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Base> ::= Float */
void Rule_Base_Float(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Fn Type> ::= fn '(' ')' */
void Rule_FnType_fn_LParen_RParen(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Fn Type> ::= fn '(' ')' '->' <Types> */
void Rule_FnType_fn_LParen_RParen_MinusGt(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Fn Type> ::= fn '(' <Types> ')' */
void Rule_FnType_fn_LParen_RParen2(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Fn Type> ::= fn '(' <Types> ')' '->' <Types> */
void Rule_FnType_fn_LParen_RParen_MinusGt2(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Pkg Template> ::= <Pkg> */
void Rule_PkgTemplate(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Pkg Template> ::= <Pkg> '<' <Types> '>' */
void Rule_PkgTemplate_Lt_Gt(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Pkg Template List> ::= <Pkg Template> ',' <Pkg Template List> */
void Rule_PkgTemplateList_Comma(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Pkg Template List> ::= <Pkg Template> */
void Rule_PkgTemplateList(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Pkg> ::= Identifier '.' <Pkg> */
void Rule_Pkg_Identifier_Dot(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Pkg> ::= Identifier */
void Rule_Pkg_Identifier(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Id List> ::= Identifier ',' <Id List> */
void Rule_IdList_Identifier_Comma(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Id List> ::= Identifier */
void Rule_IdList_Identifier(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Params> ::= <Param> ',' <Params> */
void Rule_Params_Comma(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Params> ::= <Param> */
void Rule_Params(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Param> ::= Identifier ':' <Type> */
void Rule_Param_Identifier_Colon(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Param> ::= mut Identifier ':' <Type> */
void Rule_Param_mut_Identifier_Colon(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Expr List> ::= <Expr> ',' <Expr List> */
void Rule_ExprList_Comma(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Expr List> ::= <Expr> */
void Rule_ExprList(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Expr> ::= <Var Decl Stmt> in <Expr> */
void Rule_Expr_in(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Expr> ::= match <Expr> '{' <Case Exprs> '}' */
void Rule_Expr_match_LBrace_RBrace(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Expr> ::= <Op Assign> */
void Rule_Expr(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Op Assign> ::= <Op Or> '=' <Op Assign> */
void Rule_OpAssign_Eq(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Op Assign> ::= <Op Or> '+=' <Op Assign> */
void Rule_OpAssign_PlusEq(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Op Assign> ::= <Op Or> '-=' <Op Assign> */
void Rule_OpAssign_MinusEq(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Op Assign> ::= <Op Or> '*=' <Op Assign> */
void Rule_OpAssign_TimesEq(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Op Assign> ::= <Op Or> '/=' <Op Assign> */
void Rule_OpAssign_DivEq(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Op Assign> ::= <Op Or> '%=' <Op Assign> */
void Rule_OpAssign_PercentEq(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Op Assign> ::= <Op Or> '^=' <Op Assign> */
void Rule_OpAssign_CaretEq(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Op Assign> ::= <Op Or> '&=' <Op Assign> */
void Rule_OpAssign_AmpEq(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Op Assign> ::= <Op Or> '|=' <Op Assign> */
void Rule_OpAssign_PipeEq(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Op Assign> ::= <Op Or> '>>=' <Op Assign> */
void Rule_OpAssign_GtGtEq(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Op Assign> ::= <Op Or> '<<=' <Op Assign> */
void Rule_OpAssign_LtLtEq(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Op Assign> ::= <Op Or> */
void Rule_OpAssign(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Op Or> ::= <Op Or> '||' <Op And> */
void Rule_OpOr_PipePipe(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Op Or> ::= <Op And> */
void Rule_OpOr(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Op And> ::= <Op And> '&&' <Op BinOR> */
void Rule_OpAnd_AmpAmp(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Op And> ::= <Op BinOR> */
void Rule_OpAnd(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Op BinOR> ::= <Op BinOR> '|' <Op BinXOR> */
void Rule_OpBinOR_Pipe(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Op BinOR> ::= <Op BinXOR> */
void Rule_OpBinOR(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Op BinXOR> ::= <Op BinXOR> '^' <Op BinAND> */
void Rule_OpBinXOR_Caret(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Op BinXOR> ::= <Op BinAND> */
void Rule_OpBinXOR(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Op BinAND> ::= <Op BinAND> '&' <Op Equate> */
void Rule_OpBinAND_Amp(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Op BinAND> ::= <Op Equate> */
void Rule_OpBinAND(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Op Equate> ::= <Op Equate> '==' <Op Compare> */
void Rule_OpEquate_EqEq(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Op Equate> ::= <Op Equate> '!=' <Op Compare> */
void Rule_OpEquate_ExclamEq(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Op Equate> ::= <Op Compare> */
void Rule_OpEquate(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Op Compare> ::= <Op Compare> '<' <Op Shift> */
void Rule_OpCompare_Lt(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Op Compare> ::= <Op Compare> '>' <Op Shift> */
void Rule_OpCompare_Gt(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Op Compare> ::= <Op Compare> '<=' <Op Shift> */
void Rule_OpCompare_LtEq(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Op Compare> ::= <Op Compare> '>=' <Op Shift> */
void Rule_OpCompare_GtEq(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Op Compare> ::= <Op Compare> is <Type> */
void Rule_OpCompare_is(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Op Compare> ::= <Op Shift> */
void Rule_OpCompare(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Op Shift> ::= <Op Shift> '<<' <Op Add> */
void Rule_OpShift_LtLt(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Op Shift> ::= <Op Shift> '>>' <Op Add> */
void Rule_OpShift_GtGt(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Op Shift> ::= <Op Add> */
void Rule_OpShift(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Op Add> ::= <Op Add> '+' <Op Mult> */
void Rule_OpAdd_Plus(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Op Add> ::= <Op Add> '-' <Op Mult> */
void Rule_OpAdd_Minus(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Op Add> ::= <Op Mult> */
void Rule_OpAdd(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Op Mult> ::= <Op Mult> '*' <Op Unary> */
void Rule_OpMult_Times(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Op Mult> ::= <Op Mult> '/' <Op Unary> */
void Rule_OpMult_Div(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Op Mult> ::= <Op Mult> '%' <Op Unary> */
void Rule_OpMult_Percent(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Op Mult> ::= <Op Unary> */
void Rule_OpMult(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Op Unary> ::= '!' <Op Unary> */
void Rule_OpUnary_Exclam(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Op Unary> ::= '~' <Op Unary> */
void Rule_OpUnary_Tilde(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Op Unary> ::= '-' <Op Unary> */
void Rule_OpUnary_Minus(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Op Unary> ::= '++' <Op Unary> */
void Rule_OpUnary_PlusPlus(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Op Unary> ::= '--' <Op Unary> */
void Rule_OpUnary_MinusMinus(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Op Unary> ::= <Op Pointer> '++' */
void Rule_OpUnary_PlusPlus2(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Op Unary> ::= <Op Pointer> '--' */
void Rule_OpUnary_MinusMinus2(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Op Unary> ::= <Op Unary> as <Type> */
void Rule_OpUnary_as(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Op Unary> ::= <New Expr> */
void Rule_OpUnary(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Op Unary> ::= delete <Op Pointer> */
void Rule_OpUnary_delete(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Op Unary> ::= sizeof '(' <Type> ')' */
void Rule_OpUnary_sizeof_LParen_RParen(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Op Unary> ::= <Op Pointer> */
void Rule_OpUnary2(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Op Pointer> ::= <Op Pointer> '.' <Value> */
void Rule_OpPointer_Dot(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Op Pointer> ::= <Op Pointer> '[' <Expr List> ']' */
void Rule_OpPointer_LBracket_RBracket(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Op Pointer> ::= <Op Pointer> '(' <Expr List> ')' */
void Rule_OpPointer_LParen_RParen(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Op Pointer> ::= <Op Pointer> '(' ')' */
void Rule_OpPointer_LParen_RParen2(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Op Pointer> ::= <Value> */
void Rule_OpPointer(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Value> ::= OctLiteral */
void Rule_Value_OctLiteral(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Value> ::= HexLiteral */
void Rule_Value_HexLiteral(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Value> ::= DecLiteral */
void Rule_Value_DecLiteral(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Value> ::= BinLiteral */
void Rule_Value_BinLiteral(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Value> ::= StringLiteral */
void Rule_Value_StringLiteral(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Value> ::= CharLiteral */
void Rule_Value_CharLiteral(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Value> ::= FloatLiteral */
void Rule_Value_FloatLiteral(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Value> ::= null */
void Rule_Value_null(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Value> ::= '_' */
void Rule_Value__(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Value> ::= true */
void Rule_Value_true(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Value> ::= false */
void Rule_Value_false(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Value> ::= <Pkg> */
void Rule_Value(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Value> ::= <Lambda Expr> */
void Rule_Value2(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Value> ::= '(' <Expr List> ')' */
void Rule_Value_LParen_RParen(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Value> ::= '[' for Identifier ':' <Type> in <Expr> '=>' <Expr> ']' */
void Rule_Value_LBracket_for_Identifier_Colon_in_EqGt_RBracket(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Value> ::= '[' for Identifier in <Expr> '=>' <Expr> ']' */
void Rule_Value_LBracket_for_Identifier_in_EqGt_RBracket(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Value> ::= '[' for Identifier ':' <Type> in <Expr> if <Expr> '=>' <Expr> ']' */
void Rule_Value_LBracket_for_Identifier_Colon_in_if_EqGt_RBracket(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Value> ::= '[' for Identifier in <Expr> if <Expr> '=>' <Expr> ']' */
void Rule_Value_LBracket_for_Identifier_in_if_EqGt_RBracket(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Value> ::= '[' <Expr List> ']' */
void Rule_Value_LBracket_RBracket(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Lambda Expr> ::= lambda '(' <Params> ')' <Block> */
void Rule_LambdaExpr_lambda_LParen_RParen(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Lambda Expr> ::= lambda '(' <Params> ')' '=' <Expr> */
void Rule_LambdaExpr_lambda_LParen_RParen_Eq(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Lambda Expr> ::= lambda '(' <Params> ')' '->' <Type> <Block> */
void Rule_LambdaExpr_lambda_LParen_RParen_MinusGt(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Lambda Expr> ::= lambda '(' <Params> ')' '->' <Type> '=' <Expr> */
void Rule_LambdaExpr_lambda_LParen_RParen_MinusGt_Eq(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Case Exprs> ::= case <Expr> when <Expr> '=>' <Expr> <Case Exprs> */
void Rule_CaseExprs_case_when_EqGt(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Case Exprs> ::= case <Expr> '=>' <Expr> <Case Exprs> */
void Rule_CaseExprs_case_EqGt(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <Case Exprs> ::= else '=>' <Expr> */
void Rule_CaseExprs_else_EqGt(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <New Expr> ::= new <Pkg Template> '(' ')' */
void Rule_NewExpr_new_LParen_RParen(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <New Expr> ::= new <Pkg Template> '(' <Expr> ')' */
void Rule_NewExpr_new_LParen_RParen2(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <New Expr> ::= new <Type> */
void Rule_NewExpr_new(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/* <New Expr> ::= new <Type> '[' <Expr> ']' */
void Rule_NewExpr_new_LBracket_RBracket(struct TokenStruct *Token, struct ContextStruct *Context) {
  RuleTemplate(Token,Context);
  };




/***** Rule jumptable *******************************************************/




void (*RuleJumpTable[])(struct TokenStruct *Token, struct ContextStruct *Context) = {

  /* 0. <Program> ::= <Import Section> <Declarations> */
  Rule_Program,

  /* 1. <Import Section> ::= import '(' <Import Expr List> ')' */
  Rule_ImportSection_import_LParen_RParen,

  /* 2. <Import Section> ::= import '(' ')' */
  Rule_ImportSection_import_LParen_RParen2,

  /* 3. <Import Section> ::=  */
  Rule_ImportSection,

  /* 4. <Import Expr List> ::= <Import Path> ',' <Import Expr List> */
  Rule_ImportExprList_Comma,

  /* 5. <Import Expr List> ::= <Import Path> */
  Rule_ImportExprList,

  /* 6. <Import Path> ::= Identifier '.' <Import Path> */
  Rule_ImportPath_Identifier_Dot,

  /* 7. <Import Path> ::= Identifier */
  Rule_ImportPath_Identifier,

  /* 8. <Declarations> ::= <Decl> <Declarations> */
  Rule_Declarations,

  /* 9. <Declarations> ::=  */
  Rule_Declarations2,

  /* 10. <Decl> ::= <LType Decl> */
  Rule_Decl,

  /* 11. <Decl> ::= <LVar Decl> */
  Rule_Decl2,

  /* 12. <Decl> ::= <LFunction Decl> */
  Rule_Decl3,

  /* 13. <LType Decl> ::= local <Type Decl> */
  Rule_LTypeDecl_local,

  /* 14. <LType Decl> ::= <Type Decl> */
  Rule_LTypeDecl,

  /* 15. <Type Decl> ::= <Enum Decl> */
  Rule_TypeDecl,

  /* 16. <Type Decl> ::= <Interface Def> */
  Rule_TypeDecl2,

  /* 17. <Type Decl> ::= <Class Def> */
  Rule_TypeDecl3,

  /* 18. <Type Decl> ::= <Type Def> */
  Rule_TypeDecl4,

  /* 19. <Enum Decl> ::= enum Identifier '{' <Enum Values> '}' */
  Rule_EnumDecl_enum_Identifier_LBrace_RBrace,

  /* 20. <Enum Values> ::= <Enum Value> ',' <Enum Values> */
  Rule_EnumValues_Comma,

  /* 21. <Enum Values> ::= <Enum Value> */
  Rule_EnumValues,

  /* 22. <Enum Value> ::= Identifier */
  Rule_EnumValue_Identifier,

  /* 23. <Interface Def> ::= interface Identifier '{' <Interface Methods> '}' */
  Rule_InterfaceDef_interface_Identifier_LBrace_RBrace,

  /* 24. <Interface Def> ::= interface Identifier '<' <Id List> '>' '{' <Interface Methods> '}' */
  Rule_InterfaceDef_interface_Identifier_Lt_Gt_LBrace_RBrace,

  /* 25. <Interface Methods> ::= <Interface Method> <Interface Methods> */
  Rule_InterfaceMethods,

  /* 26. <Interface Methods> ::= <Interface Method> */
  Rule_InterfaceMethods2,

  /* 27. <Interface Method> ::= function <Func Name> '(' <Params> ')' '->' <Types> */
  Rule_InterfaceMethod_function_LParen_RParen_MinusGt,

  /* 28. <Interface Method> ::= function <Func Name> '(' ')' '->' <Types> */
  Rule_InterfaceMethod_function_LParen_RParen_MinusGt2,

  /* 29. <Interface Method> ::= function <Func Name> '(' <Params> ')' */
  Rule_InterfaceMethod_function_LParen_RParen,

  /* 30. <Interface Method> ::= function <Func Name> '(' ')' */
  Rule_InterfaceMethod_function_LParen_RParen2,

  /* 31. <Interface Method> ::= local function <Func Name> '(' <Params> ')' '->' <Types> */
  Rule_InterfaceMethod_local_function_LParen_RParen_MinusGt,

  /* 32. <Interface Method> ::= local function <Func Name> '(' ')' '->' <Types> */
  Rule_InterfaceMethod_local_function_LParen_RParen_MinusGt2,

  /* 33. <Interface Method> ::= local function <Func Name> '(' <Params> ')' */
  Rule_InterfaceMethod_local_function_LParen_RParen,

  /* 34. <Interface Method> ::= local function <Func Name> '(' ')' */
  Rule_InterfaceMethod_local_function_LParen_RParen2,

  /* 35. <Interface Method> ::= synchronized function <Func Name> '(' <Params> ')' '->' <Types> */
  Rule_InterfaceMethod_synchronized_function_LParen_RParen_MinusGt,

  /* 36. <Interface Method> ::= synchronized function <Func Name> '(' ')' '->' <Types> */
  Rule_InterfaceMethod_synchronized_function_LParen_RParen_MinusGt2,

  /* 37. <Interface Method> ::= synchronized function <Func Name> '(' <Params> ')' */
  Rule_InterfaceMethod_synchronized_function_LParen_RParen,

  /* 38. <Interface Method> ::= synchronized function <Func Name> '(' ')' */
  Rule_InterfaceMethod_synchronized_function_LParen_RParen2,

  /* 39. <Interface Method> ::= local synchronized function <Func Name> '(' <Params> ')' '->' <Types> */
  Rule_InterfaceMethod_local_synchronized_function_LParen_RParen_MinusGt,

  /* 40. <Interface Method> ::= local synchronized function <Func Name> '(' ')' '->' <Types> */
  Rule_InterfaceMethod_local_synchronized_function_LParen_RParen_MinusGt2,

  /* 41. <Interface Method> ::= local synchronized function <Func Name> '(' <Params> ')' */
  Rule_InterfaceMethod_local_synchronized_function_LParen_RParen,

  /* 42. <Interface Method> ::= local synchronized function <Func Name> '(' ')' */
  Rule_InterfaceMethod_local_synchronized_function_LParen_RParen2,

  /* 43. <Interface Method> ::= synchronized local function <Func Name> '(' <Params> ')' '->' <Types> */
  Rule_InterfaceMethod_synchronized_local_function_LParen_RParen_MinusGt,

  /* 44. <Interface Method> ::= synchronized local function <Func Name> '(' ')' '->' <Types> */
  Rule_InterfaceMethod_synchronized_local_function_LParen_RParen_MinusGt2,

  /* 45. <Interface Method> ::= synchronized local function <Func Name> '(' <Params> ')' */
  Rule_InterfaceMethod_synchronized_local_function_LParen_RParen,

  /* 46. <Interface Method> ::= synchronized local function <Func Name> '(' ')' */
  Rule_InterfaceMethod_synchronized_local_function_LParen_RParen2,

  /* 47. <Func Name> ::= Identifier */
  Rule_FuncName_Identifier,

  /* 48. <Func Name> ::= <Overrideable Operator> */
  Rule_FuncName,

  /* 49. <Class Def> ::= class Identifier '{' <Class Decls> '}' */
  Rule_ClassDef_class_Identifier_LBrace_RBrace,

  /* 50. <Class Def> ::= class Identifier implements <Pkg Template List> '{' <Class Decls> '}' */
  Rule_ClassDef_class_Identifier_implements_LBrace_RBrace,

  /* 51. <Class Def> ::= immutable class Identifier '{' <Class Decls> '}' */
  Rule_ClassDef_immutable_class_Identifier_LBrace_RBrace,

  /* 52. <Class Def> ::= immutable class Identifier implements <Pkg Template List> '{' <Class Decls> '}' */
  Rule_ClassDef_immutable_class_Identifier_implements_LBrace_RBrace,

  /* 53. <Class Decls> ::= <Class Decl> <Class Decls> */
  Rule_ClassDecls,

  /* 54. <Class Decls> ::= <Class Decl> */
  Rule_ClassDecls2,

  /* 55. <Class Decl> ::= <Class Method Decl> */
  Rule_ClassDecl,

  /* 56. <Class Decl> ::= <Class Variable Decl> */
  Rule_ClassDecl2,

  /* 57. <Class Method Decl> ::= <Interface Method> '=' <Expr> */
  Rule_ClassMethodDecl_Eq,

  /* 58. <Class Method Decl> ::= <Interface Method> <Block> */
  Rule_ClassMethodDecl,

  /* 59. <Class Variable Decl> ::= <LVar Decl> */
  Rule_ClassVariableDecl,

  /* 60. <Type Def> ::= type Identifier '=' <Type> */
  Rule_TypeDef_type_Identifier_Eq,

  /* 61. <Overrideable Operator> ::= '+' */
  Rule_OverrideableOperator_Plus,

  /* 62. <Overrideable Operator> ::= '-' */
  Rule_OverrideableOperator_Minus,

  /* 63. <Overrideable Operator> ::= '*' */
  Rule_OverrideableOperator_Times,

  /* 64. <Overrideable Operator> ::= '/' */
  Rule_OverrideableOperator_Div,

  /* 65. <Overrideable Operator> ::= '%' */
  Rule_OverrideableOperator_Percent,

  /* 66. <Overrideable Operator> ::= '^' */
  Rule_OverrideableOperator_Caret,

  /* 67. <Overrideable Operator> ::= '&' */
  Rule_OverrideableOperator_Amp,

  /* 68. <Overrideable Operator> ::= '|' */
  Rule_OverrideableOperator_Pipe,

  /* 69. <Overrideable Operator> ::= '~' */
  Rule_OverrideableOperator_Tilde,

  /* 70. <Overrideable Operator> ::= '!' */
  Rule_OverrideableOperator_Exclam,

  /* 71. <Overrideable Operator> ::= '=' */
  Rule_OverrideableOperator_Eq,

  /* 72. <Overrideable Operator> ::= '<' */
  Rule_OverrideableOperator_Lt,

  /* 73. <Overrideable Operator> ::= '>' */
  Rule_OverrideableOperator_Gt,

  /* 74. <Overrideable Operator> ::= '+=' */
  Rule_OverrideableOperator_PlusEq,

  /* 75. <Overrideable Operator> ::= '-=' */
  Rule_OverrideableOperator_MinusEq,

  /* 76. <Overrideable Operator> ::= '*=' */
  Rule_OverrideableOperator_TimesEq,

  /* 77. <Overrideable Operator> ::= '/=' */
  Rule_OverrideableOperator_DivEq,

  /* 78. <Overrideable Operator> ::= '%=' */
  Rule_OverrideableOperator_PercentEq,

  /* 79. <Overrideable Operator> ::= '^=' */
  Rule_OverrideableOperator_CaretEq,

  /* 80. <Overrideable Operator> ::= '&=' */
  Rule_OverrideableOperator_AmpEq,

  /* 81. <Overrideable Operator> ::= '|=' */
  Rule_OverrideableOperator_PipeEq,

  /* 82. <Overrideable Operator> ::= '<<' */
  Rule_OverrideableOperator_LtLt,

  /* 83. <Overrideable Operator> ::= '>>' */
  Rule_OverrideableOperator_GtGt,

  /* 84. <Overrideable Operator> ::= '>>=' */
  Rule_OverrideableOperator_GtGtEq,

  /* 85. <Overrideable Operator> ::= '<<=' */
  Rule_OverrideableOperator_LtLtEq,

  /* 86. <Overrideable Operator> ::= '==' */
  Rule_OverrideableOperator_EqEq,

  /* 87. <Overrideable Operator> ::= '!=' */
  Rule_OverrideableOperator_ExclamEq,

  /* 88. <Overrideable Operator> ::= '<=' */
  Rule_OverrideableOperator_LtEq,

  /* 89. <Overrideable Operator> ::= '>=' */
  Rule_OverrideableOperator_GtEq,

  /* 90. <Overrideable Operator> ::= '&&' */
  Rule_OverrideableOperator_AmpAmp,

  /* 91. <Overrideable Operator> ::= '||' */
  Rule_OverrideableOperator_PipePipe,

  /* 92. <Overrideable Operator> ::= '++' */
  Rule_OverrideableOperator_PlusPlus,

  /* 93. <Overrideable Operator> ::= '--' */
  Rule_OverrideableOperator_MinusMinus,

  /* 94. <Overrideable Operator> ::= ',' */
  Rule_OverrideableOperator_Comma,

  /* 95. <Overrideable Operator> ::= '(' ')' */
  Rule_OverrideableOperator_LParen_RParen,

  /* 96. <Overrideable Operator> ::= '[' ']' */
  Rule_OverrideableOperator_LBracket_RBracket,

  /* 97. <Overrideable Operator> ::= new */
  Rule_OverrideableOperator_new,

  /* 98. <Overrideable Operator> ::= free */
  Rule_OverrideableOperator_free,

  /* 99. <LFunction Decl> ::= <Interface Method> '=' <Expr> */
  Rule_LFunctionDecl_Eq,

  /* 100. <LFunction Decl> ::= <Interface Method> <Block> */
  Rule_LFunctionDecl,

  /* 101. <LVar Decl> ::= let <Id List> ':' <Type> '=' <Expr List> */
  Rule_LVarDecl_let_Colon_Eq,

  /* 102. <LVar Decl> ::= let <Id List> ':' <Type> */
  Rule_LVarDecl_let_Colon,

  /* 103. <LVar Decl> ::= let <Id List> '=' <Expr List> */
  Rule_LVarDecl_let_Eq,

  /* 104. <LVar Decl> ::= let mut <Id List> ':' <Type> '=' <Expr List> */
  Rule_LVarDecl_let_mut_Colon_Eq,

  /* 105. <LVar Decl> ::= let mut <Id List> '=' <Expr List> */
  Rule_LVarDecl_let_mut_Eq,

  /* 106. <LVar Decl> ::= let local <Id List> ':' <Type> '=' <Expr List> */
  Rule_LVarDecl_let_local_Colon_Eq,

  /* 107. <LVar Decl> ::= let local <Id List> ':' <Type> */
  Rule_LVarDecl_let_local_Colon,

  /* 108. <LVar Decl> ::= let local <Id List> '=' <Expr List> */
  Rule_LVarDecl_let_local_Eq,

  /* 109. <LVar Decl> ::= let mut local <Id List> ':' <Type> '=' <Expr List> */
  Rule_LVarDecl_let_mut_local_Colon_Eq,

  /* 110. <LVar Decl> ::= let mut local <Id List> '=' <Expr List> */
  Rule_LVarDecl_let_mut_local_Eq,

  /* 111. <LVar Decl> ::= let local mut <Id List> ':' <Type> '=' <Expr List> */
  Rule_LVarDecl_let_local_mut_Colon_Eq,

  /* 112. <LVar Decl> ::= let local mut <Id List> '=' <Expr List> */
  Rule_LVarDecl_let_local_mut_Eq,

  /* 113. <Statements> ::= <Stmt> <Statements> */
  Rule_Statements,

  /* 114. <Statements> ::= <Stmt> */
  Rule_Statements2,

  /* 115. <Stmt> ::= <Block> */
  Rule_Stmt,

  /* 116. <Stmt> ::= <Var Decl Stmt> */
  Rule_Stmt2,

  /* 117. <Stmt> ::= <Repeat Stmt> */
  Rule_Stmt3,

  /* 118. <Stmt> ::= <While Stmt> */
  Rule_Stmt4,

  /* 119. <Stmt> ::= <For Stmt> */
  Rule_Stmt5,

  /* 120. <Stmt> ::= <Foreach Stmt> */
  Rule_Stmt6,

  /* 121. <Stmt> ::= <Expr> */
  Rule_Stmt7,

  /* 122. <Stmt> ::= <Return Stmt> */
  Rule_Stmt8,

  /* 123. <Stmt> ::= <Break Stmt> */
  Rule_Stmt9,

  /* 124. <Stmt> ::= <Continue Stmt> */
  Rule_Stmt10,

  /* 125. <Stmt> ::= <If Stmt> */
  Rule_Stmt11,

  /* 126. <Stmt> ::= <Match Stmt> */
  Rule_Stmt12,

  /* 127. <Block> ::= '{' <Statements> '}' */
  Rule_Block_LBrace_RBrace,

  /* 128. <Block> ::= synchronized '{' <Statements> '}' */
  Rule_Block_synchronized_LBrace_RBrace,

  /* 129. <Var Decl Stmt> ::= let <Id List> ':' <Type> '=' <Expr List> */
  Rule_VarDeclStmt_let_Colon_Eq,

  /* 130. <Var Decl Stmt> ::= let <Id List> ':' <Type> */
  Rule_VarDeclStmt_let_Colon,

  /* 131. <Var Decl Stmt> ::= let <Id List> '=' <Expr List> */
  Rule_VarDeclStmt_let_Eq,

  /* 132. <Var Decl Stmt> ::= let mut <Id List> ':' <Type> '=' <Expr List> */
  Rule_VarDeclStmt_let_mut_Colon_Eq,

  /* 133. <Var Decl Stmt> ::= let mut <Id List> '=' <Expr List> */
  Rule_VarDeclStmt_let_mut_Eq,

  /* 134. <Repeat Stmt> ::= repeat <Block> while <Expr> */
  Rule_RepeatStmt_repeat_while,

  /* 135. <While Stmt> ::= while <Expr> <Block> */
  Rule_WhileStmt_while,

  /* 136. <For Stmt> ::= for <Expr List> ';' <Expr> ';' <Expr List> <Block> */
  Rule_ForStmt_for_Semi_Semi,

  /* 137. <Foreach Stmt> ::= foreach Identifier ':' <Type> in <Expr> <Block> */
  Rule_ForeachStmt_foreach_Identifier_Colon_in,

  /* 138. <Return Stmt> ::= return <Expr List> */
  Rule_ReturnStmt_return,

  /* 139. <Return Stmt> ::= return */
  Rule_ReturnStmt_return2,

  /* 140. <Continue Stmt> ::= continue */
  Rule_ContinueStmt_continue,

  /* 141. <Break Stmt> ::= break */
  Rule_BreakStmt_break,

  /* 142. <If Stmt> ::= if <Expr> <Block> <Else If Stmt> */
  Rule_IfStmt_if,

  /* 143. <Else If Stmt> ::= else <If Stmt> <Else If Stmt> */
  Rule_ElseIfStmt_else,

  /* 144. <Else If Stmt> ::= <Else Stmt> */
  Rule_ElseIfStmt,

  /* 145. <Else If Stmt> ::=  */
  Rule_ElseIfStmt2,

  /* 146. <Else Stmt> ::= else <Block> */
  Rule_ElseStmt_else,

  /* 147. <Match Stmt> ::= match <Expr List> '{' <Match List> <Else Element> '}' */
  Rule_MatchStmt_match_LBrace_RBrace,

  /* 148. <Match Stmt> ::= match <Expr List> '{' <Match List> '}' */
  Rule_MatchStmt_match_LBrace_RBrace2,

  /* 149. <Match List> ::= <Match Element> <Match List> */
  Rule_MatchList,

  /* 150. <Match List> ::= <Match Element> */
  Rule_MatchList2,

  /* 151. <Match Element> ::= <Expr List> <Block> */
  Rule_MatchElement,

  /* 152. <Else Element> ::= else <Block> */
  Rule_ElseElement_else,

  /* 153. <Types> ::= <Type> ',' <Types> */
  Rule_Types_Comma,

  /* 154. <Types> ::= <Type> */
  Rule_Types,

  /* 155. <Type> ::= <Base> */
  Rule_Type,

  /* 156. <Type> ::= <Fn Type> */
  Rule_Type2,

  /* 157. <Type> ::= <Pkg Template> */
  Rule_Type3,

  /* 158. <Type> ::= <Type> '[' ']' */
  Rule_Type_LBracket_RBracket,

  /* 159. <Type> ::= '(' <Types> ')' */
  Rule_Type_LParen_RParen,

  /* 160. <Type> ::= '[' <Pkg Template List> ']' */
  Rule_Type_LBracket_RBracket2,

  /* 161. <Base> ::= Byte */
  Rule_Base_Byte,

  /* 162. <Base> ::= Char */
  Rule_Base_Char,

  /* 163. <Base> ::= Bool */
  Rule_Base_Bool,

  /* 164. <Base> ::= 'Int8' */
  Rule_Base_Int8,

  /* 165. <Base> ::= 'UInt8' */
  Rule_Base_UInt8,

  /* 166. <Base> ::= 'Int16' */
  Rule_Base_Int16,

  /* 167. <Base> ::= 'UInt16' */
  Rule_Base_UInt16,

  /* 168. <Base> ::= 'Int32' */
  Rule_Base_Int32,

  /* 169. <Base> ::= 'UInt32' */
  Rule_Base_UInt32,

  /* 170. <Base> ::= 'Int64' */
  Rule_Base_Int64,

  /* 171. <Base> ::= 'UInt64' */
  Rule_Base_UInt64,

  /* 172. <Base> ::= Double */
  Rule_Base_Double,

  /* 173. <Base> ::= Float */
  Rule_Base_Float,

  /* 174. <Fn Type> ::= fn '(' ')' */
  Rule_FnType_fn_LParen_RParen,

  /* 175. <Fn Type> ::= fn '(' ')' '->' <Types> */
  Rule_FnType_fn_LParen_RParen_MinusGt,

  /* 176. <Fn Type> ::= fn '(' <Types> ')' */
  Rule_FnType_fn_LParen_RParen2,

  /* 177. <Fn Type> ::= fn '(' <Types> ')' '->' <Types> */
  Rule_FnType_fn_LParen_RParen_MinusGt2,

  /* 178. <Pkg Template> ::= <Pkg> */
  Rule_PkgTemplate,

  /* 179. <Pkg Template> ::= <Pkg> '<' <Types> '>' */
  Rule_PkgTemplate_Lt_Gt,

  /* 180. <Pkg Template List> ::= <Pkg Template> ',' <Pkg Template List> */
  Rule_PkgTemplateList_Comma,

  /* 181. <Pkg Template List> ::= <Pkg Template> */
  Rule_PkgTemplateList,

  /* 182. <Pkg> ::= Identifier '.' <Pkg> */
  Rule_Pkg_Identifier_Dot,

  /* 183. <Pkg> ::= Identifier */
  Rule_Pkg_Identifier,

  /* 184. <Id List> ::= Identifier ',' <Id List> */
  Rule_IdList_Identifier_Comma,

  /* 185. <Id List> ::= Identifier */
  Rule_IdList_Identifier,

  /* 186. <Params> ::= <Param> ',' <Params> */
  Rule_Params_Comma,

  /* 187. <Params> ::= <Param> */
  Rule_Params,

  /* 188. <Param> ::= Identifier ':' <Type> */
  Rule_Param_Identifier_Colon,

  /* 189. <Param> ::= mut Identifier ':' <Type> */
  Rule_Param_mut_Identifier_Colon,

  /* 190. <Expr List> ::= <Expr> ',' <Expr List> */
  Rule_ExprList_Comma,

  /* 191. <Expr List> ::= <Expr> */
  Rule_ExprList,

  /* 192. <Expr> ::= <Var Decl Stmt> in <Expr> */
  Rule_Expr_in,

  /* 193. <Expr> ::= match <Expr> '{' <Case Exprs> '}' */
  Rule_Expr_match_LBrace_RBrace,

  /* 194. <Expr> ::= <Op Assign> */
  Rule_Expr,

  /* 195. <Op Assign> ::= <Op Or> '=' <Op Assign> */
  Rule_OpAssign_Eq,

  /* 196. <Op Assign> ::= <Op Or> '+=' <Op Assign> */
  Rule_OpAssign_PlusEq,

  /* 197. <Op Assign> ::= <Op Or> '-=' <Op Assign> */
  Rule_OpAssign_MinusEq,

  /* 198. <Op Assign> ::= <Op Or> '*=' <Op Assign> */
  Rule_OpAssign_TimesEq,

  /* 199. <Op Assign> ::= <Op Or> '/=' <Op Assign> */
  Rule_OpAssign_DivEq,

  /* 200. <Op Assign> ::= <Op Or> '%=' <Op Assign> */
  Rule_OpAssign_PercentEq,

  /* 201. <Op Assign> ::= <Op Or> '^=' <Op Assign> */
  Rule_OpAssign_CaretEq,

  /* 202. <Op Assign> ::= <Op Or> '&=' <Op Assign> */
  Rule_OpAssign_AmpEq,

  /* 203. <Op Assign> ::= <Op Or> '|=' <Op Assign> */
  Rule_OpAssign_PipeEq,

  /* 204. <Op Assign> ::= <Op Or> '>>=' <Op Assign> */
  Rule_OpAssign_GtGtEq,

  /* 205. <Op Assign> ::= <Op Or> '<<=' <Op Assign> */
  Rule_OpAssign_LtLtEq,

  /* 206. <Op Assign> ::= <Op Or> */
  Rule_OpAssign,

  /* 207. <Op Or> ::= <Op Or> '||' <Op And> */
  Rule_OpOr_PipePipe,

  /* 208. <Op Or> ::= <Op And> */
  Rule_OpOr,

  /* 209. <Op And> ::= <Op And> '&&' <Op BinOR> */
  Rule_OpAnd_AmpAmp,

  /* 210. <Op And> ::= <Op BinOR> */
  Rule_OpAnd,

  /* 211. <Op BinOR> ::= <Op BinOR> '|' <Op BinXOR> */
  Rule_OpBinOR_Pipe,

  /* 212. <Op BinOR> ::= <Op BinXOR> */
  Rule_OpBinOR,

  /* 213. <Op BinXOR> ::= <Op BinXOR> '^' <Op BinAND> */
  Rule_OpBinXOR_Caret,

  /* 214. <Op BinXOR> ::= <Op BinAND> */
  Rule_OpBinXOR,

  /* 215. <Op BinAND> ::= <Op BinAND> '&' <Op Equate> */
  Rule_OpBinAND_Amp,

  /* 216. <Op BinAND> ::= <Op Equate> */
  Rule_OpBinAND,

  /* 217. <Op Equate> ::= <Op Equate> '==' <Op Compare> */
  Rule_OpEquate_EqEq,

  /* 218. <Op Equate> ::= <Op Equate> '!=' <Op Compare> */
  Rule_OpEquate_ExclamEq,

  /* 219. <Op Equate> ::= <Op Compare> */
  Rule_OpEquate,

  /* 220. <Op Compare> ::= <Op Compare> '<' <Op Shift> */
  Rule_OpCompare_Lt,

  /* 221. <Op Compare> ::= <Op Compare> '>' <Op Shift> */
  Rule_OpCompare_Gt,

  /* 222. <Op Compare> ::= <Op Compare> '<=' <Op Shift> */
  Rule_OpCompare_LtEq,

  /* 223. <Op Compare> ::= <Op Compare> '>=' <Op Shift> */
  Rule_OpCompare_GtEq,

  /* 224. <Op Compare> ::= <Op Compare> is <Type> */
  Rule_OpCompare_is,

  /* 225. <Op Compare> ::= <Op Shift> */
  Rule_OpCompare,

  /* 226. <Op Shift> ::= <Op Shift> '<<' <Op Add> */
  Rule_OpShift_LtLt,

  /* 227. <Op Shift> ::= <Op Shift> '>>' <Op Add> */
  Rule_OpShift_GtGt,

  /* 228. <Op Shift> ::= <Op Add> */
  Rule_OpShift,

  /* 229. <Op Add> ::= <Op Add> '+' <Op Mult> */
  Rule_OpAdd_Plus,

  /* 230. <Op Add> ::= <Op Add> '-' <Op Mult> */
  Rule_OpAdd_Minus,

  /* 231. <Op Add> ::= <Op Mult> */
  Rule_OpAdd,

  /* 232. <Op Mult> ::= <Op Mult> '*' <Op Unary> */
  Rule_OpMult_Times,

  /* 233. <Op Mult> ::= <Op Mult> '/' <Op Unary> */
  Rule_OpMult_Div,

  /* 234. <Op Mult> ::= <Op Mult> '%' <Op Unary> */
  Rule_OpMult_Percent,

  /* 235. <Op Mult> ::= <Op Unary> */
  Rule_OpMult,

  /* 236. <Op Unary> ::= '!' <Op Unary> */
  Rule_OpUnary_Exclam,

  /* 237. <Op Unary> ::= '~' <Op Unary> */
  Rule_OpUnary_Tilde,

  /* 238. <Op Unary> ::= '-' <Op Unary> */
  Rule_OpUnary_Minus,

  /* 239. <Op Unary> ::= '++' <Op Unary> */
  Rule_OpUnary_PlusPlus,

  /* 240. <Op Unary> ::= '--' <Op Unary> */
  Rule_OpUnary_MinusMinus,

  /* 241. <Op Unary> ::= <Op Pointer> '++' */
  Rule_OpUnary_PlusPlus2,

  /* 242. <Op Unary> ::= <Op Pointer> '--' */
  Rule_OpUnary_MinusMinus2,

  /* 243. <Op Unary> ::= <Op Unary> as <Type> */
  Rule_OpUnary_as,

  /* 244. <Op Unary> ::= <New Expr> */
  Rule_OpUnary,

  /* 245. <Op Unary> ::= delete <Op Pointer> */
  Rule_OpUnary_delete,

  /* 246. <Op Unary> ::= sizeof '(' <Type> ')' */
  Rule_OpUnary_sizeof_LParen_RParen,

  /* 247. <Op Unary> ::= <Op Pointer> */
  Rule_OpUnary2,

  /* 248. <Op Pointer> ::= <Op Pointer> '.' <Value> */
  Rule_OpPointer_Dot,

  /* 249. <Op Pointer> ::= <Op Pointer> '[' <Expr List> ']' */
  Rule_OpPointer_LBracket_RBracket,

  /* 250. <Op Pointer> ::= <Op Pointer> '(' <Expr List> ')' */
  Rule_OpPointer_LParen_RParen,

  /* 251. <Op Pointer> ::= <Op Pointer> '(' ')' */
  Rule_OpPointer_LParen_RParen2,

  /* 252. <Op Pointer> ::= <Value> */
  Rule_OpPointer,

  /* 253. <Value> ::= OctLiteral */
  Rule_Value_OctLiteral,

  /* 254. <Value> ::= HexLiteral */
  Rule_Value_HexLiteral,

  /* 255. <Value> ::= DecLiteral */
  Rule_Value_DecLiteral,

  /* 256. <Value> ::= BinLiteral */
  Rule_Value_BinLiteral,

  /* 257. <Value> ::= StringLiteral */
  Rule_Value_StringLiteral,

  /* 258. <Value> ::= CharLiteral */
  Rule_Value_CharLiteral,

  /* 259. <Value> ::= FloatLiteral */
  Rule_Value_FloatLiteral,

  /* 260. <Value> ::= null */
  Rule_Value_null,

  /* 261. <Value> ::= '_' */
  Rule_Value__,

  /* 262. <Value> ::= true */
  Rule_Value_true,

  /* 263. <Value> ::= false */
  Rule_Value_false,

  /* 264. <Value> ::= <Pkg> */
  Rule_Value,

  /* 265. <Value> ::= <Lambda Expr> */
  Rule_Value2,

  /* 266. <Value> ::= '(' <Expr List> ')' */
  Rule_Value_LParen_RParen,

  /* 267. <Value> ::= '[' for Identifier ':' <Type> in <Expr> '=>' <Expr> ']' */
  Rule_Value_LBracket_for_Identifier_Colon_in_EqGt_RBracket,

  /* 268. <Value> ::= '[' for Identifier in <Expr> '=>' <Expr> ']' */
  Rule_Value_LBracket_for_Identifier_in_EqGt_RBracket,

  /* 269. <Value> ::= '[' for Identifier ':' <Type> in <Expr> if <Expr> '=>' <Expr> ']' */
  Rule_Value_LBracket_for_Identifier_Colon_in_if_EqGt_RBracket,

  /* 270. <Value> ::= '[' for Identifier in <Expr> if <Expr> '=>' <Expr> ']' */
  Rule_Value_LBracket_for_Identifier_in_if_EqGt_RBracket,

  /* 271. <Value> ::= '[' <Expr List> ']' */
  Rule_Value_LBracket_RBracket,

  /* 272. <Lambda Expr> ::= lambda '(' <Params> ')' <Block> */
  Rule_LambdaExpr_lambda_LParen_RParen,

  /* 273. <Lambda Expr> ::= lambda '(' <Params> ')' '=' <Expr> */
  Rule_LambdaExpr_lambda_LParen_RParen_Eq,

  /* 274. <Lambda Expr> ::= lambda '(' <Params> ')' '->' <Type> <Block> */
  Rule_LambdaExpr_lambda_LParen_RParen_MinusGt,

  /* 275. <Lambda Expr> ::= lambda '(' <Params> ')' '->' <Type> '=' <Expr> */
  Rule_LambdaExpr_lambda_LParen_RParen_MinusGt_Eq,

  /* 276. <Case Exprs> ::= case <Expr> when <Expr> '=>' <Expr> <Case Exprs> */
  Rule_CaseExprs_case_when_EqGt,

  /* 277. <Case Exprs> ::= case <Expr> '=>' <Expr> <Case Exprs> */
  Rule_CaseExprs_case_EqGt,

  /* 278. <Case Exprs> ::= else '=>' <Expr> */
  Rule_CaseExprs_else_EqGt,

  /* 279. <New Expr> ::= new <Pkg Template> '(' ')' */
  Rule_NewExpr_new_LParen_RParen,

  /* 280. <New Expr> ::= new <Pkg Template> '(' <Expr> ')' */
  Rule_NewExpr_new_LParen_RParen2,

  /* 281. <New Expr> ::= new <Type> */
  Rule_NewExpr_new,

  /* 282. <New Expr> ::= new <Type> '[' <Expr> ']' */
  Rule_NewExpr_new_LBracket_RBracket 
  };


  /***** Main *****************************************************************/



void parseAst(struct TokenStruct *Token, struct ContextStruct *parent)
{
	RuleJumpTable[Token->ReductionRule](Token, parent);
	size_t i = 0;
    /*
	for(; i < context->imports->size; i++)
	{
		ImportExpr* ie = getElement(context->imports, i);
		char* path = calloc(ie->filePathSize+1, sizeof(char));
		wcstombs(path, ie->filePath, ie->filePathSize+1);
		
		debugf("compiling %s", path);
		
		if(!fileExists(path))
		{
			char* path2 = calloc(strlen(path)+libDirSize+1, sizeof(char));
			strcat(path2, libDir);
			strcat(path2, path);
			
			if(fileExists(path2))
			{
				 debugf("compiling %s", path2);
				 compile(path2);
			}
			
		}
		else{
			debugf("compiling %s", path);
			compile(path);
		}
	}
	
	for (i = 0; i < context->funcs->size; i++)
	{
		addElement(parentExpr->funcs, getElement(context->funcs, i));
	}
	for (i = 0; i < context->classes->size; i++)
	{
		addElement(parentExpr->classes, getElement(context->classes, i));
	}
	for (i = 0; i < context->enums->size; i++)
	{
		addElement(parentExpr->enums, getElement(context->enums, i));
	}
	for (i = 0; i < context->ctypes->size; i++)
	{
		addElement(parentExpr->ctypes, getElement(context->ctypes, i));
	}
	for (i = 0; i < context->vars->size; i++)
	{
		addElement(parentExpr->vars, getElement(context->vars, i));
	}
	for (i = 0; i < context->modules->size; i++)
	{
		addElement(parentExpr->modules, getElement(context->modules, i));
	}
	for (i = 0; i < context->cdefs->size; i++)
	{
		addElement(parentExpr->cdefs, getElement(context->cdefs, i));
	}
	*/
}
